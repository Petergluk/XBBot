# Хранитель Баланса

Бот предназначен для управления внутренней экономикой сообщества с использованием Telegram. Он позволяет пользователям выполнять переводы, отслеживать балансы, управлять подписками на активности и просматривать события.

---

### **Архитектурная Документация Проекта**

#### **1. Общая концепция и архитектура**

Проект представляет собой Telegram-бота, построенного на фреймворке `aiogram 3.x`, который реализует экономическую систему для сообщества. Архитектура проекта модульная, что обеспечивает четкое разделение ответственности между компонентами.

**Ключевые архитектурные принципы:**

*   **Модульность:** Функционал разделен на логические блоки (роутеры, сервисы, утилиты), что упрощает навигацию, тестирование и дальнейшее развитие.
*   **Централизованное управление состоянием:** Для сложных многошаговых диалогов используется механизм конечных автоматов (FSM) из `aiogram`, определения которых вынесены в `app/states.py`.
*   **Асинхронность:** Проект полностью построен на асинхронной парадигме с использованием `asyncio`, что обеспечивает высокую производительность при работе с сетью (Telegram API, вебхуки).
*   **Разделение конфигурации и кода:** Все статичные настройки (токены, ID, тексты по умолчанию) вынесены в файл `config.py`, что позволяет изменять их без вмешательства в основную логику.

**Структура проекта:**

```
project/
├── app/
│   ├── database.py         # Управление базой данных SQLite
│   ├── keyboards.py        # Генераторы клавиатур
│   ├── states.py           # Определения состояний FSM
│   ├── utils.py            # Вспомогательные функции (утилиты)
│   ├── handlers/           # Обработчики сообщений и колбэков
│   │   ├── admin_commands.py
│   │   ├── activity_handlers.py
│   │   ├── common.py
│   │   ├── event_handlers.py
│   │   └── user_commands.py
│   └── services/           # Фоновые процессы и сервисы
│       ├── scheduler_jobs.py
│       └── webhook_handler.py
├── tests/
│   └── test_bot.py         # Юнит-тесты
├── main.py                 # Главный файл, точка входа в приложение
└── config.py               # Файл конфигурации
```

---

#### **2. Описание ключевых модулей**

##### **`main.py` — Точка входа**

Это дирижер всего оркестра. Его задача — инициализировать и запустить все компоненты системы в правильном порядке.

*   **Инициализация:** Создает объекты `Bot` и `Dispatcher`.
*   **Регистрация обработчиков:** Подключает все роутеры из папки `app/handlers`. Порядок подключения важен, так как `aiogram` обрабатывает обновления последовательно.
*   **Запуск планировщика:** Инициализирует `AsyncIOScheduler` и добавляет в него периодические задачи из `scheduler_jobs.py`.
*   **Параллельный запуск:** С помощью `asyncio.gather` одновременно запускает два ключевых процесса:
    1.  **Поллинг (`dp.start_polling`):** Основной цикл получения обновлений от Telegram.
    2.  **Веб-сервер (`webhook_handler.run_webhook_server`):** Сервер для приема внешних вебхуков (например, от платежной системы Tribute).

##### **`database.py` — Фундамент данных**

Этот модуль инкапсулирует всю работу с базой данных SQLite. Он спроектирован как синглтон (единый экземпляр `db` на все приложение), что обеспечивает единую точку доступа к данным.

*   **Инициализация (`init_db`):** При первом запуске создает все необходимые таблицы (`users`, `activities`, `events`, `transactions` и др.), добавляет системного пользователя "Фонд" (ID=0) и устанавливает настройки по умолчанию из `config.py`.
*   **Соединение (`get_connection`):** Предоставляет настроенное соединение с БД, включая `PRAGMA foreign_keys=ON` для обеспечения целостности данных (например, при удалении активности каскадно удаляются связанные события).
*   **Методы-хелперы:** Предоставляет удобные методы для частых операций: `get_user`, `get_setting`, `set_setting`, `get_all_admins`.
*   **Бизнес-логика (`handle_debt_repayment`):** Содержит специфичную логику, связанную с данными, например, сброс флага "кредита доверия" при пополнении баланса.

##### **`utils.py` — Инструментарий**

Набор общих, переиспользуемых функций, которые не относятся к какому-то конкретному обработчику.

*   `format_amount`: "Умное" форматирование чисел `Decimal` в строки.
*   `ensure_user_exists`: Гарантирует, что пользователь существует в БД перед выполнением любой операции.
*   `is_user_in_group`: Проверяет членство пользователя в основной группе Telegram.
*   **`process_payment` (Ключевая функция после рефакторинга):** Это сердце платежной логики. Она централизует сложный процесс распределения средств при оплате событий. Функция принимает плательщика, стоимость и детали события, а затем сама решает, куда направить деньги:
    1.  **"Сжечь" платеж** (транзакция уходит в `NULL`), если это первая подписка или разовая покупка от пользователя без подписок.
    2.  **Отправить создателю события**, если он указан.
    3.  **Отправить в фонд сообщества** (пользователю с ID=0), если создатель не найден.
    Такая централизация устранила дублирование кода и сделала бизнес-правила прозрачными.

---

#### **3. Функциональные блоки (Handlers)**

Обработчики сгруппированы по ролям в папке `app/handlers`.

*   **`common.py`:** Обрабатывает общие для всех команды (`/start`, `/help`) и события (вступление нового пользователя в чат). Реализует логику начисления Welcome-бонуса.
*   **`user_commands.py`:** Команды, доступные обычному пользователю: проверка баланса (`/balance`), перевод средств (`/send`), просмотр истории (`/history`) и статистики (`/gdp`).
*   **`admin_commands.py`:** Команды для администраторов. Доступ к ним защищен через `middleware`, который проверяет флаг `is_admin` у пользователя. Включает управление пользователями, системными настройками (демередж, welcome-сообщения) и фондом.
*   **`activity_handlers.py` и `event_handlers.py`:** Реализуют сложную логику FSM для создания и редактирования активностей и событий. `activity_handlers.py` также отвечает за подписку/отписку и покупку разового доступа (используя `utils.process_payment`).

---

#### **4. Фоновые процессы (Services)**

##### **`scheduler_jobs.py` — Автоматизация экономики**

Здесь описаны задачи, выполняемые по расписанию.

*   **`process_demurrage`:** Срабатывает раз в день. Проходит по всем пользователям с положительным балансом и списывает небольшой процент ("налог на простой") в фонд сообщества.
*   **`process_reminders`:** Срабатывает каждую минуту. Проверяет, не пора ли отправить напоминание о каком-либо событии.
*   **`process_event_payments`:** Срабатывает каждые 5 минут. Ищет события, которые должны были начаться в этот интервал, и производит списание средств с подписчиков, используя централизованную логику из `utils.process_payment`.

**Логика работы планировщика:** Как мы обсуждали, частая проверка (каждую минуту/пять минут) — это механизм **отказоустойчивости**. Если бот перезагрузится, он не пропустит события, а обработает их в следующем цикле проверки.

##### **`webhook_handler.py` — Мост во внешний мир**

Реализует веб-сервер на `aiohttp` для приема пополнений от внешней системы Tribute.

*   **`handle_tribute_webhook`:** Принимает POST-запрос, проверяет секретный ключ, парсит данные (ID пользователя и сумму), конвертирует сумму в валюту бота по курсу из настроек и зачисляет на баланс пользователя.
*   **`run_webhook_server`:** Функция, которая запускает этот сервер. В `main.py` она вызывается параллельно с основным ботом.

---

#### **5. Тестирование (`tests/test_bot.py`)**

Файл содержит набор юнит-тестов, написанных с использованием `pytest`.

*   **Назначение:** Проверка отдельных функций и логических блоков в изоляции от Telegram API.
*   **Изоляция:** Взаимодействие с Telegram API имитируется с помощью "моков" (`AsyncMock`). Это позволяет тестировать логику (например, как бот реагирует на пользователя в группе или вне ее) без реальных сетевых запросов.
*   **База данных:** Тесты работают с той же базой данных `xbbot.db`, но спроектированы так, чтобы создавать и удалять тестовых пользователей (`setup_method`), не затрагивая реальные данные.
*   **Запуск:** Для запуска тестов необходимо установить `pytest` и `pytest-asyncio` и выполнить команду `pytest` в корневой папке проекта.

Эта документация отражает текущую, сбалансированную структуру вашего проекта. Каждый элемент находится на своем месте и выполняет четко определенную функцию, создавая единую и логичную систему.